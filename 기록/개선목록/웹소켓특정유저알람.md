현재 특정 유저에게 알람을 보내기 위해 웹소켓을 사용하려고 했는데
그 전 프로젝트에서 사용한 방식보다 더 나은 방식을 찾아서 기록 해둡니다.

그 전에는
클라이언트
```tsx
stompClient.subscribe(`/sub/notification/${username}`, (message) => {
  // 헤더 알림 상태 업데이트
});
```
서버
```java
messagingTemplate.convertAndSend("/sub/notification/" + username, payload);

```
이런식으로 신호를 주고받았는데
이러한 방식의 단점으로는
```다른 사람 채널도 구독할 수 있음
프론트에서 마음만 먹으면 /sub/notification/otherUser 에도 구독 시도 가능 → 보안 이슈.

멀티 세션/멀티 디바이스 고려가 귀찮음
같은 유저가 두 브라우저에서 로그인해 있으면? 이런 걸 직접 관리해야 함.

URL 레벨에서 username이 그대로 노출되는 것도 그렇게 기분 좋은 구조는 아님.
```

라고 조사되었습니다.

더 좋은 방법: convertAndSendToUser + /user 목적지

이 방법을 사용하게 되면 
- “누가 구독할 수 있는지”는 프레임워크가 Principal 기반으로 관리
- 같은 유저의 여러 세션도 알아서 브로드캐스트됨

```java
// 웹소켓 설정
@Override
public void configureMessageBroker(MessageBrokerRegistry registry) {
    registry.enableSimpleBroker("/sub");
    registry.setApplicationDestinationPrefixes("/pub");
    registry.setUserDestinationPrefix("/user"); // 이 줄 추가
}
// 서버에서 알람 보내기
messagingTemplate.convertAndSendToUser(
                username,
                "/sub/notification",  // 클라이언트에서 /user/sub/notification 으로 구독
                dto
        );
```
>- convertAndSendToUser(username, destination, payload)
>- destination 앞에는 /user 안 붙임. Spring이 알아서 /user/{username}... 로 매핑해줌.
```tsx
// 클라이언트 구독
const subscription = stompClient.subscribe(
  "/user/sub/notification",  // 여기! username 안 붙임
  (message) => {
    const notification = JSON.parse(message.body);
  }
);
```
이런식으로 할 수도 있다는것을 배웠습니다.

- 프론트에서 username을 URL에 넣을 필요 없이
- 로그인한 유저(Principal) 기준으로만 알림이 전송됨
- 다른 유저 채널을 구독하려는 꼼수 자체가 안 통함